// testUtils.js - Утилиты для тестирования

/**
 * Создает мок объекта с глубоким клонированием
 */
function createMock(overrides = {}) {
  const defaultMock = {
    id: 1,
    name: 'Test User',
    email: 'test@example.com',
    isActive: true,
    createdAt: new Date('2024-01-01'),
    preferences: {
      theme: 'dark',
      notifications: true,
    },
  };

  return deepMerge(defaultMock, overrides);
}

/**
 * Глубокое слияние объектов
 */
function deepMerge(target, source) {
  const output = { ...target };
  
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach(key => {
      if (isObject(source[key])) {
        if (!(key in target)) {
          output[key] = source[key];
        } else {
          output[key] = deepMerge(target[key], source[key]);
        }
      } else {
        output[key] = source[key];
      }
    });
  }
  
  return output;
}

function isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item);
}

/**
 * Генератор тестовых данных
 */
class TestDataFactory {
  static createUser(overrides = {}) {
    return createMock(overrides);
  }

  static createProduct(overrides = {}) {
    const defaultProduct = {
      id: 'PROD-' + Math.random().toString(36).substr(2, 9),
      name: 'Test Product',
      price: 99.99,
      category: 'electronics',
      inStock: true,
      stockCount: 100,
      description: 'Test product description',
      createdAt: new Date(),
    };

    return deepMerge(defaultProduct, overrides);
  }

  static createOrder(overrides = {}) {
    const defaultOrder = {
      id: 'ORD-' + Math.random().toString(36).substr(2, 9),
      userId: 1,
      items: [
        { productId: 'PROD-123', quantity: 2, price: 99.99 },
        { productId: 'PROD-456', quantity: 1, price: 49.99 },
      ],
      total: 249.97,
      status: 'pending',
      shippingAddress: {
        street: '123 Test St',
        city: 'Test City',
        zipCode: '12345',
        country: 'Test Country',
      },
    };

    return deepMerge(defaultOrder, overrides);
  }
}

/**
 * Хелпер для асинхронных тестов
 */
async function waitForCondition(condition, timeout = 5000, interval = 100) {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    if (await condition()) {
      return true;
    }
    await new Promise(resolve => setTimeout(resolve, interval));
  }
  
  throw new Error(`Condition not met within ${timeout}ms`);
}

module.exports = {
  createMock,
  TestDataFactory,
  waitForCondition,
};
